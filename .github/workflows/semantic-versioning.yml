name: Semantic Versioning

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  update-version:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version bump
        id: version_bump
        run: |
          # Get PR labels
          LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' || echo "")

          # Default to patch if no label found
          BUMP_TYPE="patch"

          # Check for version labels (case-insensitive)
          if echo "$LABELS" | grep -iq "major"; then
            BUMP_TYPE="major"
          elif echo "$LABELS" | grep -iq "minor"; then
            BUMP_TYPE="minor"
          elif echo "$LABELS" | grep -iq "patch"; then
            BUMP_TYPE="patch"
          fi

          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Version bump type: $BUMP_TYPE"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Read current version
        id: current_version
        run: |
          if [ -f version.txt ]; then
            CURRENT_VERSION=$(cat version.txt | xargs)
          else
            CURRENT_VERSION="0.0.0"
          fi
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT="${{ steps.current_version.outputs.version }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          # Bump version based on type
          case "$BUMP_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Update version.txt
        run: |
          echo "${{ steps.new_version.outputs.version }}" > version.txt
          echo "Updated version.txt to ${{ steps.new_version.outputs.version }}"

      - name: Get PR details
        id: pr_details
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_TITLE=$(gh pr view $PR_NUMBER --json title --jq '.title')
          PR_BODY=$(gh pr view $PR_NUMBER --json body --jq '.body')

          # Save PR details to files for multiline handling
          echo "$PR_TITLE" > /tmp/pr_title.txt
          echo "$PR_BODY" > /tmp/pr_body.txt

          echo "PR Title: $PR_TITLE"
          echo "PR Body length: ${#PR_BODY}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update CHANGELOG.md
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          CURRENT_DATE=$(date +%Y-%m-%d)

          # Check if CHANGELOG.md exists
          if [ ! -f CHANGELOG.md ]; then
            echo "CHANGELOG.md not found, skipping update"
            exit 0
          fi

          # Read PR details
          PR_TITLE=$(cat /tmp/pr_title.txt)
          PR_BODY=$(cat /tmp/pr_body.txt)

          # Create a temporary file for the updated changelog
          TMP_FILE=$(mktemp)

          # Find the first version section or "How to Use" section to insert before
          awk -v version="$NEW_VERSION" -v date="$CURRENT_DATE" -v pr_title="$PR_TITLE" -v pr_body="$PR_BODY" '
          BEGIN {
            inserted = 0
          }

          # Insert new version before the first existing version section
          /^## \[[0-9]+\.[0-9]+\.[0-9]+\]/ && !inserted {
            print "## [" version "] - " date
            print ""
            if (length(pr_title) > 0) {
              print "### " pr_title
              print ""
            }
            if (length(pr_body) > 0) {
              print pr_body
              print ""
            }
            inserted = 1
            print $0
            next
          }

          # Insert new version before "How to Use This Changelog" if no version sections found
          /^## How to Use This Changelog/ && !inserted {
            print "## [" version "] - " date
            print ""
            if (length(pr_title) > 0) {
              print "### " pr_title
              print ""
            }
            if (length(pr_body) > 0) {
              print pr_body
              print ""
            }
            inserted = 1
            print $0
            next
          }

          # Add new version comparison link after separator line
          /^---$/ {
            print $0
            print ""
            print "[" version "]: https://github.com/k9barry/viavi/releases/tag/v" version
            next
          }

          # Skip existing version link if it matches (avoid duplicates)
          /^\[[0-9]+\.[0-9]+\.[0-9]+\]:/ {
            if ($0 !~ "\\[" version "\\]:") {
              print $0
            }
            next
          }

          # Print all other lines
          { print $0 }
          ' CHANGELOG.md > "$TMP_FILE"

          # Replace original file
          mv "$TMP_FILE" CHANGELOG.md
          echo "Updated CHANGELOG.md with version $NEW_VERSION"

      - name: Update README.md version badge
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"

          # Check if README.md exists
          if [ ! -f README.md ]; then
            echo "README.md not found, skipping update"
            exit 0
          fi

          # Update version badge
          sed -i "s/version-[0-9]\+\.[0-9]\+\.[0-9]\+-blue/version-$NEW_VERSION-blue/g" README.md
          echo "Updated README.md version badge to $NEW_VERSION"

      - name: Commit version update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add version.txt CHANGELOG.md README.md
          git commit -m "chore: bump version to ${{ steps.new_version.outputs.version }}" || echo "No changes to commit"
          git push || echo "Nothing to push"

      - name: Create Release
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          PR_TITLE=$(cat /tmp/pr_title.txt)
          PR_BODY=$(cat /tmp/pr_body.txt)

          # Create release notes file
          {
            echo "## Version ${NEW_VERSION}"
            echo ""
            echo "**Version bump type**: ${BUMP_TYPE}"
            echo ""
            echo "### ${PR_TITLE}"
            echo ""
            echo "${PR_BODY}"
            echo ""
            echo "---"
            echo ""
            echo "See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for full version history."
          } > /tmp/release_notes.md

          # Create the release
          gh release create "v$NEW_VERSION" \
            --title "Release v$NEW_VERSION" \
            --notes-file /tmp/release_notes.md \
            --repo ${{ github.repository }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
